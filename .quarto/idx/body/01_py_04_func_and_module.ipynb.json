{"title":"函数","markdown":{"yaml":{"title":"函数"},"headingText":"作用域","containsRefs":false,"markdown":"\n\n\n\n\n我们之前已经频繁的使用到了函数。\n\n函数是一个带有输入和输出的能够完成特定功能的代码块。比如，在某段程序中我们可能需要频繁的使用某一功能，比如，我们可能需要频繁的计算正态分布的密度函数，虽然我们可以使用：\n```python\npi=3.141592654\ne=2.718\nsigma=1\nmu=0\nf=1/((2*pi)**0.5*sigma)*e**(-1*(x-mu)**2/(2*sigma^2))\n```\n\n进行计算，但是以上计算公式仍然十分复杂，每次碰到都输入不仅麻烦，而且容易犯错。更方便的做法时将以上语句写成一个**函数**（**function**）。\n\n在Python中，函数可以方便的使用def来定义，比如，上面计算正态分布的密度函数的函数可以写为：\n\n\n\n在以上语句中，normden是所声明函数的函数名称，后面括号中的“x”、“mu”、“sigma”都是需要用户输入的参数：我们希望计算期望为mu，标准差为sigma的正态分布在x处的密度函数值。\n\n在函数的最后，有一个return语句，该语句用以给出函数的返回值：在本例中就是我们计算得到的密度函数值。\n\n注意如果需要函数有返回值，必须加入return语句，如果不加，函数默认返回None：\n\n此外需要注意的时，在调用函数时必须按照声明函数时的参数顺序传入参数，比如在上例中，normden(0,0,1)即对于期望为0，标准差为1的正态分布，计算x=0处的密度函数值，不能将顺序搞错。从而以下调用方式：\n```python\nnormden(0,1,0)\n```\n\n必然是错的，因为标准差不可能为0。\n\n有时对于一个足够复杂的函数，可能会有很多参数值需要传入，而有些参数是允许有默认值的，即使用函数时如果不需要改动可以不改动。此时，我们可以可以在声明函数时就给出默认值，比如，在上例中，如果我们默认计算标准正态分布（期望为0、标注差为1）的密度函数，可以这样写：\n\n如果需要指明mu或者sigma的值，只需要在调用时声明即可，比如：\n\n就计算了标准差为2、期望为0的正态分布的密度函数值。\n\n此外，我们之前提到过，为代码加注释是非常好的习惯，在Python中，由于自定义的函数有可能被其他人使用，而其他人不一定会看源代码，因而注释可能不会被看到。Python提供了一种非常方便的方法，即**文档字符串**（**docstring**），这个字符串仅仅是在函数体内、放在函数开头、不赋值给任何变量的字符串：\n\n声明了文档字符串后，可以直接使用function.\\_\\_doc\\_\\_进行调阅。\n\n\n在创建函数时，必须注意变量的作用域问题。\n\n作用域即变量的作用范围。比如，我们在normden()函数中定义了两个变量：pi和e，但是由于这两个变量是在函数体内定义的，因而外界无法使用这两个变量：\n\n可见程序出错，并提示pi这个变量没有定义。\n\n然而反过来，被定义在函数体外的变量，可以被函数所使用，比如，如果我们写成：\n\n不过，如果在函数体内重新定义了pi，则会按照函数体内的定义：\n\n## lambda表达式\n\n函数虽然好用，但是有一个缺点是，有时语句非常简单，但是我们还需要写def、return等语句。\n\nPython提供了一个语法糖，即lambda表达式，可以让我们很方便的在一行以内定义一个函数。比如刚刚计算标准正态分布的密度函数的函数可以定义为：\n\n当然，简单的代价是损失方便性，上面的lambda表达式虽然定义了标准正态分布的密度函数，但是并没有定义一般意义的正态分布的密度函数，如果需要传入额外的变量，可以使用：\n\n在这里，我们不妨回忆一下上一节中有关列表排序的内容，比如对于列表\n\n现在该列表的每个元素是一个元组，我们希望的是对每个元组的第二个元素排序。而列表的sort()函数中，key是一个参数，当这个参数不传入任何东西时，默认按照元素值进行排序；但是key参数允许传入一个函数，在进行排序时，先将每个元素带入到key的函数中，计算返回值，再根据返回值排序。比如：\n\n或者，我们可以使用lambda表达式写成更加简洁的形式：\n\n## Python中的函数式编程\n\n可能有心的读者已经注意到了，函数是可以通过等号赋予某一个变量的，甚至可以传入另外一个函数。\n\n实际上在Python中也吸收了函数式编程的一些特点，函数也是“一等公民”，跟数字、字符串一样，也可以传给一个变量、当做参数传入给另外一个函数。比如：\n\n上面的代码中，我们将已经声明的一个函数normden()赋值给了另一个变量,normden2，并使用normden2计算了0处的密度函数值。\n\n此外，我们还是用is关键字判断两者是否指代一个对象，发现两者实际上指代的同一个对象，是完全等价的。\n\n以下展示了将函数作为参数传递给另外一个函数：\n\n以上程序中，我们定义了一个新的函数，den2()，该函数接受两个参数：f和x，其中f为一个函数，可用来计算f(x)，并返回f(2)\\*\\*2。\n\n随后，我们将刚刚定义的normden()函数以及x=0传入了den2()函数，计算得到了具体数值。\n\n### 递归\n\n**递归**（**recursion**）是函数是函数值编程一个非常有意思的应用，即一个函数调用其本身。\n\n比如，为了计算阶乘，我们通常会使用循环：\n\n如果使用递归的思路，我们可以这么写：\n\n在以上程序中，我们定义了一个函数factorial()，接受一个数字作为参数：只要该参数不为1，就继续往下乘，直到编程1为止。因而，factorial(5)具体执行了：\n\n1. factorial(5), 计算5\\*factorial(4)\n1. factorial(4), 计算4\\*factorial(3)\n1. factorial(3), 计算3\\*factorial(2)\n1. factorial(2), 计算2\\*factorial(1)\n1. factorial(1)=1\n1. 最终依次返回\n\n接下来我们展示了一个二分查找的例子，可以证明，以下的二分查找比线性查找更加快速。\n\n### map()、reduce()以及filter()\n\n函数式编程另外比较常用的特性时map()、reduce()、filter等函数。\n\n其中，map(func, list)函数接受一个函数func和一个列表list，其作用是将函数func作用与list的每一个元素中。\n\n值得注意的是，map()语句之后，计算并不会立即执行，而是会返回一个可迭代的对象，等到需要计算值时才进行计算，比如：\n\n在以上程序中，我们先使用range()函数产生了一个0...9的列表，接着使用map函数，计算了每个元素的平方。注意到map()函数被调用之后，计算并没有立即执行，返回的是一个map对象。该对象是可迭代的，因而我们可以使用list()函数将其转化为列表。\n\n或者，更常用的，我们可能会使用reduce()以及filter()函数处理map对象。其中：\n\n* reduce(func,iterable_obj)接受一个二元函数，以及一个可迭代的对象iterable_obj，该函数使用func函数依次计算iterable_obj每个的值。\n    - 比如，如果iterable_obj=\\[x1,x2,x3,x4\\]，那么reduce()函数计算的是：func(func(func(x1,x2),x3),x4)\n* filter(func,iterable_ojb)接受一个逻辑函数，以及一个可迭代的对象iterable_obj，该函数的作用是将iterable_obj中带入func返回值为True的子集挑出来。\n\n\n\n比如，以下使用reduce() 函数计算了一个列表的和：\n\n以下使用reduce() 函数计算了一个列表的最大值：\n\n以下使用reduce() 函数计算了0...9的平方和：\n\n以下则挑出了所有1,...,9的平方中的所有的能被3整除的数：\n\n# 模块\n\n注意我们在使用reduce()函数时，多加了一句：\n```python\nfrom functools import reduce\n```\n\n原因是由于reduce()并非Python內建的函数，需要从functools这个模块中调用。functools这个模块是Python自带的，无需安装。\n\n\n在Python中，**模块**（**module**）通常是一个Python文件，在该文件中定义了很多函数、类、常数等供我们使用。\n\n而**包**（**package**）是一个目录，包中可以有很多的模块。\n\n我们之前曾经讲过，使用类似“pip install bs4”之类的命令安装包，安装好之后就可以供我们在Python程序中调用。\n\n如果需要使用某个模块，可以直接使用“import”命令。比如，我们经常使用的带有一些数学函数的math模块：\n\n注意在上面我们在使用math模块中的元素时，都加了math.的前缀，这是由于Python中的命名空间导致的，为了防止在不同的地方定义了相同的函数名等。比如：\n\n为了防止混乱，特地使用math.前缀作为区分。\n\n如果需要同时导入多个模块，可以直接用逗号隔开，比如以下程序我们使用梯形公式计算了标准正态分布函数从-1.96到1.96的数值积分：\n\n注意到，我们使用import 语句同时导入了functools以及math两个模块，因而在这里我们需要使用functools.reduce来表示reduce()函数。\n\n当然，我们也看到了，可以直接使用： from ... import ... 的语法来导入模块中的某一个元素，比如from functools import reduce就从functools模块中导入了reduce函数，且reduce函数使用时不需要再加functools.前缀。\n\n当然，不需要前缀的代价是要小心不要覆盖已经导入的东西，比如：\n\n此外，import 语句还可以为导入的东西起别名，比如 import math as m，以后就可以使用m.sin()、m.e、m.pi、m.log()、m.exp()等替代math.sin() 等等。\n","srcMarkdownNoYaml":"\n\n\n\n\n我们之前已经频繁的使用到了函数。\n\n函数是一个带有输入和输出的能够完成特定功能的代码块。比如，在某段程序中我们可能需要频繁的使用某一功能，比如，我们可能需要频繁的计算正态分布的密度函数，虽然我们可以使用：\n```python\npi=3.141592654\ne=2.718\nsigma=1\nmu=0\nf=1/((2*pi)**0.5*sigma)*e**(-1*(x-mu)**2/(2*sigma^2))\n```\n\n进行计算，但是以上计算公式仍然十分复杂，每次碰到都输入不仅麻烦，而且容易犯错。更方便的做法时将以上语句写成一个**函数**（**function**）。\n\n在Python中，函数可以方便的使用def来定义，比如，上面计算正态分布的密度函数的函数可以写为：\n\n\n\n在以上语句中，normden是所声明函数的函数名称，后面括号中的“x”、“mu”、“sigma”都是需要用户输入的参数：我们希望计算期望为mu，标准差为sigma的正态分布在x处的密度函数值。\n\n在函数的最后，有一个return语句，该语句用以给出函数的返回值：在本例中就是我们计算得到的密度函数值。\n\n注意如果需要函数有返回值，必须加入return语句，如果不加，函数默认返回None：\n\n此外需要注意的时，在调用函数时必须按照声明函数时的参数顺序传入参数，比如在上例中，normden(0,0,1)即对于期望为0，标准差为1的正态分布，计算x=0处的密度函数值，不能将顺序搞错。从而以下调用方式：\n```python\nnormden(0,1,0)\n```\n\n必然是错的，因为标准差不可能为0。\n\n有时对于一个足够复杂的函数，可能会有很多参数值需要传入，而有些参数是允许有默认值的，即使用函数时如果不需要改动可以不改动。此时，我们可以可以在声明函数时就给出默认值，比如，在上例中，如果我们默认计算标准正态分布（期望为0、标注差为1）的密度函数，可以这样写：\n\n如果需要指明mu或者sigma的值，只需要在调用时声明即可，比如：\n\n就计算了标准差为2、期望为0的正态分布的密度函数值。\n\n此外，我们之前提到过，为代码加注释是非常好的习惯，在Python中，由于自定义的函数有可能被其他人使用，而其他人不一定会看源代码，因而注释可能不会被看到。Python提供了一种非常方便的方法，即**文档字符串**（**docstring**），这个字符串仅仅是在函数体内、放在函数开头、不赋值给任何变量的字符串：\n\n声明了文档字符串后，可以直接使用function.\\_\\_doc\\_\\_进行调阅。\n\n## 作用域\n\n在创建函数时，必须注意变量的作用域问题。\n\n作用域即变量的作用范围。比如，我们在normden()函数中定义了两个变量：pi和e，但是由于这两个变量是在函数体内定义的，因而外界无法使用这两个变量：\n\n可见程序出错，并提示pi这个变量没有定义。\n\n然而反过来，被定义在函数体外的变量，可以被函数所使用，比如，如果我们写成：\n\n不过，如果在函数体内重新定义了pi，则会按照函数体内的定义：\n\n## lambda表达式\n\n函数虽然好用，但是有一个缺点是，有时语句非常简单，但是我们还需要写def、return等语句。\n\nPython提供了一个语法糖，即lambda表达式，可以让我们很方便的在一行以内定义一个函数。比如刚刚计算标准正态分布的密度函数的函数可以定义为：\n\n当然，简单的代价是损失方便性，上面的lambda表达式虽然定义了标准正态分布的密度函数，但是并没有定义一般意义的正态分布的密度函数，如果需要传入额外的变量，可以使用：\n\n在这里，我们不妨回忆一下上一节中有关列表排序的内容，比如对于列表\n\n现在该列表的每个元素是一个元组，我们希望的是对每个元组的第二个元素排序。而列表的sort()函数中，key是一个参数，当这个参数不传入任何东西时，默认按照元素值进行排序；但是key参数允许传入一个函数，在进行排序时，先将每个元素带入到key的函数中，计算返回值，再根据返回值排序。比如：\n\n或者，我们可以使用lambda表达式写成更加简洁的形式：\n\n## Python中的函数式编程\n\n可能有心的读者已经注意到了，函数是可以通过等号赋予某一个变量的，甚至可以传入另外一个函数。\n\n实际上在Python中也吸收了函数式编程的一些特点，函数也是“一等公民”，跟数字、字符串一样，也可以传给一个变量、当做参数传入给另外一个函数。比如：\n\n上面的代码中，我们将已经声明的一个函数normden()赋值给了另一个变量,normden2，并使用normden2计算了0处的密度函数值。\n\n此外，我们还是用is关键字判断两者是否指代一个对象，发现两者实际上指代的同一个对象，是完全等价的。\n\n以下展示了将函数作为参数传递给另外一个函数：\n\n以上程序中，我们定义了一个新的函数，den2()，该函数接受两个参数：f和x，其中f为一个函数，可用来计算f(x)，并返回f(2)\\*\\*2。\n\n随后，我们将刚刚定义的normden()函数以及x=0传入了den2()函数，计算得到了具体数值。\n\n### 递归\n\n**递归**（**recursion**）是函数是函数值编程一个非常有意思的应用，即一个函数调用其本身。\n\n比如，为了计算阶乘，我们通常会使用循环：\n\n如果使用递归的思路，我们可以这么写：\n\n在以上程序中，我们定义了一个函数factorial()，接受一个数字作为参数：只要该参数不为1，就继续往下乘，直到编程1为止。因而，factorial(5)具体执行了：\n\n1. factorial(5), 计算5\\*factorial(4)\n1. factorial(4), 计算4\\*factorial(3)\n1. factorial(3), 计算3\\*factorial(2)\n1. factorial(2), 计算2\\*factorial(1)\n1. factorial(1)=1\n1. 最终依次返回\n\n接下来我们展示了一个二分查找的例子，可以证明，以下的二分查找比线性查找更加快速。\n\n### map()、reduce()以及filter()\n\n函数式编程另外比较常用的特性时map()、reduce()、filter等函数。\n\n其中，map(func, list)函数接受一个函数func和一个列表list，其作用是将函数func作用与list的每一个元素中。\n\n值得注意的是，map()语句之后，计算并不会立即执行，而是会返回一个可迭代的对象，等到需要计算值时才进行计算，比如：\n\n在以上程序中，我们先使用range()函数产生了一个0...9的列表，接着使用map函数，计算了每个元素的平方。注意到map()函数被调用之后，计算并没有立即执行，返回的是一个map对象。该对象是可迭代的，因而我们可以使用list()函数将其转化为列表。\n\n或者，更常用的，我们可能会使用reduce()以及filter()函数处理map对象。其中：\n\n* reduce(func,iterable_obj)接受一个二元函数，以及一个可迭代的对象iterable_obj，该函数使用func函数依次计算iterable_obj每个的值。\n    - 比如，如果iterable_obj=\\[x1,x2,x3,x4\\]，那么reduce()函数计算的是：func(func(func(x1,x2),x3),x4)\n* filter(func,iterable_ojb)接受一个逻辑函数，以及一个可迭代的对象iterable_obj，该函数的作用是将iterable_obj中带入func返回值为True的子集挑出来。\n\n\n\n比如，以下使用reduce() 函数计算了一个列表的和：\n\n以下使用reduce() 函数计算了一个列表的最大值：\n\n以下使用reduce() 函数计算了0...9的平方和：\n\n以下则挑出了所有1,...,9的平方中的所有的能被3整除的数：\n\n# 模块\n\n注意我们在使用reduce()函数时，多加了一句：\n```python\nfrom functools import reduce\n```\n\n原因是由于reduce()并非Python內建的函数，需要从functools这个模块中调用。functools这个模块是Python自带的，无需安装。\n\n\n在Python中，**模块**（**module**）通常是一个Python文件，在该文件中定义了很多函数、类、常数等供我们使用。\n\n而**包**（**package**）是一个目录，包中可以有很多的模块。\n\n我们之前曾经讲过，使用类似“pip install bs4”之类的命令安装包，安装好之后就可以供我们在Python程序中调用。\n\n如果需要使用某个模块，可以直接使用“import”命令。比如，我们经常使用的带有一些数学函数的math模块：\n\n注意在上面我们在使用math模块中的元素时，都加了math.的前缀，这是由于Python中的命名空间导致的，为了防止在不同的地方定义了相同的函数名等。比如：\n\n为了防止混乱，特地使用math.前缀作为区分。\n\n如果需要同时导入多个模块，可以直接用逗号隔开，比如以下程序我们使用梯形公式计算了标准正态分布函数从-1.96到1.96的数值积分：\n\n注意到，我们使用import 语句同时导入了functools以及math两个模块，因而在这里我们需要使用functools.reduce来表示reduce()函数。\n\n当然，我们也看到了，可以直接使用： from ... import ... 的语法来导入模块中的某一个元素，比如from functools import reduce就从functools模块中导入了reduce函数，且reduce函数使用时不需要再加functools.前缀。\n\n当然，不需要前缀的代价是要小心不要覆盖已经导入的东西，比如：\n\n此外，import 语句还可以为导入的东西起别名，比如 import math as m，以后就可以使用m.sin()、m.e、m.pi、m.log()、m.exp()等替代math.sin() 等等。\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"highlight-style":"atom-one","css":["../styles.css"],"output-file":"01_py_04_func_and_module.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","editor":"visual","theme":"cosmo","linestretch":1.6,"fontsize":"11.5pt","highlight":true,"callout-appearance":"default","md-extensions":["callout"],"includes":{"after-body":"../_includes/counter.html"},"title":"函数"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}