{"title":"Python：语法解析-面向对象编程","markdown":{"yaml":{"title":"Python：语法解析-面向对象编程"},"headingText":"简介","containsRefs":false,"markdown":"\n\n\n\n\n> “Python 是一门面向对象的编程语言”  \n\n\n本章的目的不是教你编程，而是为了让你更好地理解 Python 的语法规则。\n\n对于初学 Python 的人而言，“Python 是一门面向对象的编程 (OOP) 语言” 这样的表述想必并不陌生。然而，“面向对象”究竟是什么，尤其是“对象”的概念，却常常让人摸不着头脑。以众多 Stata 老用户为例，当他们初次见到下面这段代码时，往往会陷入困惑：\n\n\n\n\n\n在 `mtcars = sm.datasets.get_rdataset('mtcars', 'datasets').data` 这条语句中，呈现出 `sm.A.B().C` 的形式。初学者不免产生如下疑问：\n\n- 这里面哪些是函数 (function)？\n- 哪些是方法 (method)？\n- 哪些又是对象的属性呢？\n- 需要学习哪些概念才能搞清楚这些语句的编写规则？\n\n同样令人费解的语句还有 `model1 = sm.OLS(y, X1).fit()`。\n\n上述问题其实是近两年 Python 学习者普遍面临的困惑。有了 AI 助手（如豆包、Copilot 等），很多人得以快速上手 Python。但好景不长，大家很快就会遭遇瓶颈。面对 AI 自动生成的代码，自己往往一知半解，基本不具备调试和修改代码的能力。这就导致在使用 Python 一段时间后，自身编写代码的能力始终难以显著提升，还总是花费大量时间进行调试，从而无法集中精力思考更高级的问题。\n\n为此，本文将详细介绍 Python 面向对象编程的核心概念，帮你深入理解 Python 代码的逻辑和结构关系，进而提升编写 Python 代码的能力。接下来，我们就将逐步解答上述代码中的疑问。\n\n\n\n## 类 v.s 对象：直观解释\n\n>**解读 1 - 填写表格**：空白表是「类」，填好的表式「对象 (实例)」\n\n我们经常需要填写纸质或电子表格：去医院看病、网上购物、或者参加婚礼需要回复 RSVP。**表格**就是一种标准化的方式，方便他人或机构收集你的信息。不同的表格关注的信息各不相同：你会在医生的表格上填写敏感的健康状况，而婚礼邀请回复表格则关注你会带几位嘉宾 —— 这两种信息互不相干。\n\n在 Python 中，**class**（类）、**type**（类型）、**data type**（数据类型）这些术语基本等价。可以按照如下逻辑来理解：\n\n- 可以把**类**看作是 Python **对象**（也称为「实例」）的**模板 (blueprint)**；\n- 对象则是具体的数据实体，代表某个「名词」（可以是医院里的病人、网上的购物订单、婚礼的嘉宾等等）。\n- **类**就像是一张空白表格模板，而**对象**就是基于这个模板，实际填写了数据的具体表格。\n\n比如，下图中的 RSVP 回复表格就是类的一个例子，而具体填写好的 RSVP 回执，就是一个对象：\n\n![](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250509083144.png)\n\nSource：[15 Object-Oriented Programming and Classes](https://inventwithpython.com/beyond/chapter15.html)\n\n\n&emsp;\n\n>**另一种类比**：电子表格（Excel）\n\n你还可以把类和对象类比为电子表格（比如 Excel），如下图所示。表格的**列名**就类似于类（定义了每个属性），而表格的每一**行**就相当于一个具体对象（包含具体的数据）。\n\n![](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250509083406.png)\n\n下面，我们做详细介绍。\n\n## 类、对象、封装、继承和多态\n\n### 类（Class）\n\n类是对象的模板，它定义了对象的属性和方法，可将其视为一种自定义的数据类型。以 `Person` 类为例：\n\n\n\n\n`Person` 类包含两个函数，分别是 `__init__()` 和 `introduce()`。前者用于定义「对象的**属性**」，后者用于定义「对象的**方法**」。具体说明如下：\n\n- `__init__()` 是一个特殊的函数，称为「构造函数」。它的作用是在创建类的对象时，初始化 **对象的属性**。在这个例子里，`__init__()` 定义了 `Person` 类的两个属性，即 `name` 和 `age`。\n- `introduce()` 函数定义了 `Person` 类的一个**方法**，其功能是打印出对象的 `name` 和 `age` 信息。\n\n这里要着重说明一下 `self` 这个参数。在 Python 的类中，`self` 是一个约定俗成的参数名，它代表类的实例对象本身。当你调用类的方法时，Python 会自动将调用该方法的对象作为第一个参数传递给 `self`。借助 `self`，方法能够访问和修改对象的属性。\n\n例如，在 `__init__()` 方法里，`self.name = name` 这一操作把传入的 `name` 参数值赋给了对象的 `name` 属性；在 `introduce()` 方法中，`self.name` 和 `self.age` 用于获取对象的 `name` 和 `age` 属性值。\n\n### 对象（Object）\n\n对象是类的实例。通过类能够创建多个不同的对象，每个对象都有自己独立的属性值。例如：\n\n\n\n此例中，`p1` 和 `p2` 是 `Person` 类的两个不同对象。`p1.name` 的值是 \"张三\"，`p2.name` 的值是 \"李四\"，这体现了不同对象的属性可以有不同的值。\n\n\n\n### 封装（Encapsulation）\n\n封装是面向对象编程的一个重要特性，它指的是将数据（属性）和操作数据的方法捆绑在一起，并且对外部隐藏对象的内部实现细节。封装的作用主要体现在以下几个方面：\n\n- **数据保护**：防止外部代码直接访问和修改对象的属性，从而避免数据被意外修改或破坏。\n- **简化接口**：只向外部暴露必要的方法，隐藏内部实现细节，降低外部代码与对象之间的耦合度，使代码更易于维护和扩展。\n\n在 Python 中，可以通过访问控制来实现封装。虽然 Python 没有像其他语言那样严格的访问修饰符（如 `private`、`protected`），但可以通过约定来表示属性或方法的访问级别。以单下划线开头的属性或方法被视为受保护的，以双下划线开头的属性或方法被视为私有的。例如：\n\n\n\n在这个例子中，`__balance` 是一个私有属性，外部不能直接访问，只能通过 `deposit`、`withdraw` 和 `get_balance` 等方法来操作。这样就保证了账户余额的安全性，外部代码无法随意修改余额。\n\n### 4. 继承（Inheritance）\n\n继承是指一个类可以继承另一个类的属性和方法。被继承的类称为父类（基类），继承的类称为子类（派生类）。子类可以扩展父类的功能，也可以重写父类的方法。例如：\n\n\n\n\n在这个例子中，`Student` 类继承了 `Person` 类的属性和方法，并添加了自己的属性 `student_id` 和方法 `study`。`super().__init__(name, age)` 调用了父类的构造函数，对 `name` 和 `age` 属性进行初始化。\n\n### 多态（Polymorphism）\n\n多态是指不同的对象可以对同一个操作做出不同的响应。下面通过几个例子来帮助你理解多态的概念和应用。\n\n#### 简单数据类型示例\n\n```python\na = 5\nb = \"apple\"\nprint(a * 3)  # 输出: 15\nprint(b * 3)  # 输出: appleappleapple\n\n```\n\n可见，`*` 运算符对于整数 `a` 和字符串 `b` 有不同的行为：\n\n- 对于整数，`*` 表示乘法运算；\n- 对于字符串，`*` 表示重复字符串。\n\n这就是多态的体现，同一个运算符在不同的数据类型上有不同的操作。\n\n#### 类的方法重写示例\n\n\n\n\n在这个例子中，`Rectangle` 和 `Circle` 类都继承自 `Shape` 类，并且重写了 `area` 方法。当我们遍历 `shapes` 列表并调用每个对象的 `area` 方法时，不同的对象会根据自己的实现方式计算并返回面积，这也是多态的应用。\n\n#### Python 支持多态的原因\n\nPython 能够支持多态，主要得益于其动态类型的特性。在 Python 中，变量在声明时不需要预先指定数据类型，变量的类型是在运行时动态确定的。这意味着一个变量可以在不同的时刻引用不同类型的对象。当调用一个函数或方法时，Python 不会关心对象的具体类型，只要对象实现了所需的方法或属性，就可以正常调用。\n\n这种特性使得 Python 代码更加灵活，能够轻松实现多态。例如，在上面的 `shapes` 列表中，`Rectangle` 和 `Circle` 对象虽然类型不同，但都实现了 `area` 方法，因此可以统一调用 `area` 方法来计算面积。\n\n### 面向对象概念在具体包和函数中的应用\n\n在实际的 Python 编程中，面向对象编程的概念广泛应用于各种包和函数中。下面以 `pandas` 和 `matplotlib` 这两个常用的包为例进行说明。\n\n#### `pandas` 中的应用\n\n`pandas` 是一个用于数据处理和分析的强大包，其中大量使用了类和对象的概念。例如，`DataFrame` 是 `pandas` 中最常用的类之一，用于表示二维表格数据。\n\n\n\n\n此例中，`pd.DataFrame` 是一个类，`df` 是 `DataFrame` 类的一个对象。\n\n我们可以调用 `df` 对象的各种方法，如 `head()` 和 `describe()`，来对数据进行操作和分析。甚至可以采用链式调用的方式来连续执行多个操作，如 `df.describe().T.round(2)` 表示对 `df` 对象依次进行如下操作：计算基本统计量 &rarr; 转置 &rarr; 四舍五入 (保留两位有效数字)。\n\n\n\n#### `matplotlib` 中的应用\n\n`matplotlib` 是一个用于数据可视化的包，也广泛应用了面向对象编程的思想。例如，我们可以使用 `Figure` 和 `Axes` 类来创建和定制图形。\n\n\n\n\n\n在这个例子中，`fig` 是 `Figure` 类的对象，`ax` 是 `Axes` 类的对象。\n\n我们可以通过调用 `ax` 对象的方法，如 `plot()`、`set_title()`、`set_xlabel()` 和 `set_ylabel()` 来绘制和定制图形。这体现了面向对象编程在 `matplotlib` 中的应用，通过将图形的不同部分封装成对象，使得图形的创建和定制更加灵活和可控。\n\n\n## 包、函数、方法和属性\n\n我们先简要介绍一下理解复杂语句所需的基础概念。\n\n### 包（Package）和模块（Module）\n\n#### 模块（Module）\n\n- 模块是单个 `.py` 文件，包含函数、类、变量等代码。\n- 例如：\n  - `arrow.api.py` 是一个模块，包含 `get()` 函数。\n  - `numpy.random.py` 也是一个模块，内含若干个用于生成随机数的函数。\n\n#### 包（Package）\n\n包是一个包含多个模块的**目录**，通常还包含一个 `__init__.py` 文件。\n\n一个包中可以包含多个子包，而每个包中又可以包含多个模块。包的目录结构类似于文件系统的目录结构。`__init__.py` 文件的作用是标识该目录是一个包，更重要的是，它详细记录了这个包里都有哪些模块和子包。\n\n包通过目录结构组织代码，例如：\n\n  ```python\n  pandas/               # 根包\n    __init__.py         # 标识这是一个包\n    core/               # 子包\n      __init__.py\n      frame.py          # 模块（定义 DataFrame）\n      series.py         # 模块（定义 Series）\n    io/                 # 子包\n      __init__.py\n      excel.py          # 模块（处理 Excel 文件）\n  ```\n\n比如，`arrow` 是一个用于处理日期和时间的包，该包的程序文件存放于 `arrow` 目录下：\n\n![](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250524004230.png)\n\n其中包含 `__init__.py` 文件和其他模块文件（如 `arrow.py`、`util.py` 等）。当你使用 `import arrow` 时，Python 会自动执行 `__init__.py` 文件中的代码，从而初始化包的命名空间。\n\n你若执行 `from arrow import api`，则会导入 `arrow` 包中的 `api` 模块。然后你可以使用 `api` 模块中的函数和类，例如 `api.get()`。\n\n\n同理，你可以使用如下方法查看其他包的路径：\n\n\n\n### 函数（Function）和方法（Method）\n\n函数是一段完成特定任务的独立代码块，可以直接调用。而方法是与对象关联的函数，必须通过对象来调用。例如，\n\n- 在 `sm.datasets.get_rdataset()` 中，`get_rdataset()` 是一个函数，它属于 `statsmodels` 包中 `datasets` 模块。\n- 在 `model1 = sm.OLS(y, X1).fit()` 中：\n  - `OLS()` 是 `sm` 包中的一个函数，用于创建一个普通最小二乘回归模型对象。\n  - `sm.OLS(y, X1)` 创建了一个 `OLS` **对象**。\n    - `fit()` 是 `sm.OLS(y, X1)` 创建的对象的**方法**。\n\n#### 类中的属性（Attribute）和方法（Method）\n\n**属性** 是类或对象的数据成员，而 **方法** 则是类或对象的函数成员。\n\n因此，在 `mtcars = sm.datasets.get_rdataset('mtcars', 'datasets').data` 中，`.data` 就是 `get_rdataset()` 函数返回的对象的一个属性，里面存储着对象里的数据。\n\n## 解析复杂语句\n\n现在我们来详细解析引言中提到的复杂语句：\n\n```python\nimport statsmodels.api as sm\n\n# 加载示例数据\nmtcars = sm.datasets.get_rdataset('mtcars', 'datasets').data\nmtcars.head()\n```\n\n具体解释如下：\n\n- `sm` 是 `statsmodels.api` 模块的别名。\n- `datasets` 是 `sm` 下的一个子模块，专门用于访问内置或外部数据集。\n- `get_rdataset('mtcars', 'datasets')` 是 `datasets` 子模块中的一个函数，用于从 R 的数据集仓库中的 **datasets** 包中获取名为 `'mtcars'` 的数据集。这个函数会返回一个包含数据集及其元信息 (meta information) 的对象 (可以假想为名称为 **mtcars_object** 的对象)。\n- `.data` 是对象 **mtcars_object** 的一个属性，用于提取实际的数据内容（通常为一个 `pandas.DataFrame`）。\n- 因此，最终得到的 `mtcars` 变量就是一个 `pandas.DataFrame` 对象，包含了 `'mtcars'` 数据集的实际数据。\n- `mtcars.head()` 是 `pandas.DataFrame` 对象的方法，用于查看数据集的前几行数据。\n\n需要注意的是，在上述语句中，`datasets` 这个关键词出现了两次，两者含义不同，不要混淆：\n\n- 第一次是指 `sm` 下的 `datasets` 子模块；\n- 第二次是作为参数传递给 `get_rdataset()` 函数，它是 R 语言中的一个扩展包的名称，而 `mtcars` 则是 **datasets** 包中的一个数据集。\n\n把上述代码拆成两行更有助于理解 **模块**、**函数** 和 **属性** 这三个概念的区别：\n\n```python\nimport statsmodels.api as sm\n\n# 获取数据集对象：'object = 模块.函数()' 格式\n#        本例中：'object = 模块.子模块.函数(参数1, 参数2)' 格式\nmtcars_object = sm.datasets.get_rdataset('mtcars', 'datasets') \n\n# 获取数据集内容：'object.属性' 格式\nmtcars_df = mtcars_object.data \n```\n\n可以将这行代码拆解为以下几步，更便于初学者理解：\n\n```python\n# 第一步：获取 datasets 子模块\ndatasets_module = sm.datasets\n\n# 第二步：调用 get_rdataset 函数获取数据集对象\nrdataset = datasets_module.get_rdataset('mtcars', 'datasets')\n  # - 'mtcars' 是数据集的名称\n  # - 'datasets' 是数据集所在的包名\n# 第三步：通过 data 属性获取实际的数据\nmtcars = rdataset.data\n```\n\n至此，代码的第二部分也很容易理解了：\n\n```python\n# 模型 1\nX1 = data[['weight']]\nX1 = sm.add_constant(X1)\ny = data['mpg']\nmodel1 = sm.OLS(y, X1).fit()\n```\n\n解释如下：\n\n- `sm.OLS(y, X1)`：\n    - `OLS` 是 `statsmodels.api` 模块中的一个类，用于创建一个普通最小二乘回归模型的对象。这里传入的参数 `y` 是因变量，`X1` 是自变量。\n- `.fit()`：是 `sm.OLS(y, X1)` 创建的对象的方法，用于拟合模型，即根据输入的数据计算模型的参数。\n\n \n\n\n## 参考资料\n\n- [Python 100 Days - 18.面向对象编程入门](https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/18.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8.md)\n\n\n\n\n## 总结\n\n- 模块是单个 `.py` 文件，包含函数、类、变量等代码。\n- 包是一个包含多个模块的目录，通常还包含一个 `__init__.py` 文件。\n- 类是对象的模板，它定义了对象的属性和方法。\n- 对象是类的实例。通过类能够创建多个不同的对象，每个对象都有自己独立的属性值。\n- 封装是将数据（属性）和操作数据的方法捆绑在一起，并对外部隐藏对象的内部实现细节。\n- 继承是一个类可以继承另一个类的属性和方法。\n- 多态是指不同的对象可以对同一个操作做出不同的响应。\n- 函数是一段完成特定任务的独立代码块，可以直接调用。\n","srcMarkdownNoYaml":"\n\n\n\n\n> “Python 是一门面向对象的编程语言”  \n\n## 简介\n\n本章的目的不是教你编程，而是为了让你更好地理解 Python 的语法规则。\n\n对于初学 Python 的人而言，“Python 是一门面向对象的编程 (OOP) 语言” 这样的表述想必并不陌生。然而，“面向对象”究竟是什么，尤其是“对象”的概念，却常常让人摸不着头脑。以众多 Stata 老用户为例，当他们初次见到下面这段代码时，往往会陷入困惑：\n\n\n\n\n\n在 `mtcars = sm.datasets.get_rdataset('mtcars', 'datasets').data` 这条语句中，呈现出 `sm.A.B().C` 的形式。初学者不免产生如下疑问：\n\n- 这里面哪些是函数 (function)？\n- 哪些是方法 (method)？\n- 哪些又是对象的属性呢？\n- 需要学习哪些概念才能搞清楚这些语句的编写规则？\n\n同样令人费解的语句还有 `model1 = sm.OLS(y, X1).fit()`。\n\n上述问题其实是近两年 Python 学习者普遍面临的困惑。有了 AI 助手（如豆包、Copilot 等），很多人得以快速上手 Python。但好景不长，大家很快就会遭遇瓶颈。面对 AI 自动生成的代码，自己往往一知半解，基本不具备调试和修改代码的能力。这就导致在使用 Python 一段时间后，自身编写代码的能力始终难以显著提升，还总是花费大量时间进行调试，从而无法集中精力思考更高级的问题。\n\n为此，本文将详细介绍 Python 面向对象编程的核心概念，帮你深入理解 Python 代码的逻辑和结构关系，进而提升编写 Python 代码的能力。接下来，我们就将逐步解答上述代码中的疑问。\n\n\n\n## 类 v.s 对象：直观解释\n\n>**解读 1 - 填写表格**：空白表是「类」，填好的表式「对象 (实例)」\n\n我们经常需要填写纸质或电子表格：去医院看病、网上购物、或者参加婚礼需要回复 RSVP。**表格**就是一种标准化的方式，方便他人或机构收集你的信息。不同的表格关注的信息各不相同：你会在医生的表格上填写敏感的健康状况，而婚礼邀请回复表格则关注你会带几位嘉宾 —— 这两种信息互不相干。\n\n在 Python 中，**class**（类）、**type**（类型）、**data type**（数据类型）这些术语基本等价。可以按照如下逻辑来理解：\n\n- 可以把**类**看作是 Python **对象**（也称为「实例」）的**模板 (blueprint)**；\n- 对象则是具体的数据实体，代表某个「名词」（可以是医院里的病人、网上的购物订单、婚礼的嘉宾等等）。\n- **类**就像是一张空白表格模板，而**对象**就是基于这个模板，实际填写了数据的具体表格。\n\n比如，下图中的 RSVP 回复表格就是类的一个例子，而具体填写好的 RSVP 回执，就是一个对象：\n\n![](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250509083144.png)\n\nSource：[15 Object-Oriented Programming and Classes](https://inventwithpython.com/beyond/chapter15.html)\n\n\n&emsp;\n\n>**另一种类比**：电子表格（Excel）\n\n你还可以把类和对象类比为电子表格（比如 Excel），如下图所示。表格的**列名**就类似于类（定义了每个属性），而表格的每一**行**就相当于一个具体对象（包含具体的数据）。\n\n![](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250509083406.png)\n\n下面，我们做详细介绍。\n\n## 类、对象、封装、继承和多态\n\n### 类（Class）\n\n类是对象的模板，它定义了对象的属性和方法，可将其视为一种自定义的数据类型。以 `Person` 类为例：\n\n\n\n\n`Person` 类包含两个函数，分别是 `__init__()` 和 `introduce()`。前者用于定义「对象的**属性**」，后者用于定义「对象的**方法**」。具体说明如下：\n\n- `__init__()` 是一个特殊的函数，称为「构造函数」。它的作用是在创建类的对象时，初始化 **对象的属性**。在这个例子里，`__init__()` 定义了 `Person` 类的两个属性，即 `name` 和 `age`。\n- `introduce()` 函数定义了 `Person` 类的一个**方法**，其功能是打印出对象的 `name` 和 `age` 信息。\n\n这里要着重说明一下 `self` 这个参数。在 Python 的类中，`self` 是一个约定俗成的参数名，它代表类的实例对象本身。当你调用类的方法时，Python 会自动将调用该方法的对象作为第一个参数传递给 `self`。借助 `self`，方法能够访问和修改对象的属性。\n\n例如，在 `__init__()` 方法里，`self.name = name` 这一操作把传入的 `name` 参数值赋给了对象的 `name` 属性；在 `introduce()` 方法中，`self.name` 和 `self.age` 用于获取对象的 `name` 和 `age` 属性值。\n\n### 对象（Object）\n\n对象是类的实例。通过类能够创建多个不同的对象，每个对象都有自己独立的属性值。例如：\n\n\n\n此例中，`p1` 和 `p2` 是 `Person` 类的两个不同对象。`p1.name` 的值是 \"张三\"，`p2.name` 的值是 \"李四\"，这体现了不同对象的属性可以有不同的值。\n\n\n\n### 封装（Encapsulation）\n\n封装是面向对象编程的一个重要特性，它指的是将数据（属性）和操作数据的方法捆绑在一起，并且对外部隐藏对象的内部实现细节。封装的作用主要体现在以下几个方面：\n\n- **数据保护**：防止外部代码直接访问和修改对象的属性，从而避免数据被意外修改或破坏。\n- **简化接口**：只向外部暴露必要的方法，隐藏内部实现细节，降低外部代码与对象之间的耦合度，使代码更易于维护和扩展。\n\n在 Python 中，可以通过访问控制来实现封装。虽然 Python 没有像其他语言那样严格的访问修饰符（如 `private`、`protected`），但可以通过约定来表示属性或方法的访问级别。以单下划线开头的属性或方法被视为受保护的，以双下划线开头的属性或方法被视为私有的。例如：\n\n\n\n在这个例子中，`__balance` 是一个私有属性，外部不能直接访问，只能通过 `deposit`、`withdraw` 和 `get_balance` 等方法来操作。这样就保证了账户余额的安全性，外部代码无法随意修改余额。\n\n### 4. 继承（Inheritance）\n\n继承是指一个类可以继承另一个类的属性和方法。被继承的类称为父类（基类），继承的类称为子类（派生类）。子类可以扩展父类的功能，也可以重写父类的方法。例如：\n\n\n\n\n在这个例子中，`Student` 类继承了 `Person` 类的属性和方法，并添加了自己的属性 `student_id` 和方法 `study`。`super().__init__(name, age)` 调用了父类的构造函数，对 `name` 和 `age` 属性进行初始化。\n\n### 多态（Polymorphism）\n\n多态是指不同的对象可以对同一个操作做出不同的响应。下面通过几个例子来帮助你理解多态的概念和应用。\n\n#### 简单数据类型示例\n\n```python\na = 5\nb = \"apple\"\nprint(a * 3)  # 输出: 15\nprint(b * 3)  # 输出: appleappleapple\n\n```\n\n可见，`*` 运算符对于整数 `a` 和字符串 `b` 有不同的行为：\n\n- 对于整数，`*` 表示乘法运算；\n- 对于字符串，`*` 表示重复字符串。\n\n这就是多态的体现，同一个运算符在不同的数据类型上有不同的操作。\n\n#### 类的方法重写示例\n\n\n\n\n在这个例子中，`Rectangle` 和 `Circle` 类都继承自 `Shape` 类，并且重写了 `area` 方法。当我们遍历 `shapes` 列表并调用每个对象的 `area` 方法时，不同的对象会根据自己的实现方式计算并返回面积，这也是多态的应用。\n\n#### Python 支持多态的原因\n\nPython 能够支持多态，主要得益于其动态类型的特性。在 Python 中，变量在声明时不需要预先指定数据类型，变量的类型是在运行时动态确定的。这意味着一个变量可以在不同的时刻引用不同类型的对象。当调用一个函数或方法时，Python 不会关心对象的具体类型，只要对象实现了所需的方法或属性，就可以正常调用。\n\n这种特性使得 Python 代码更加灵活，能够轻松实现多态。例如，在上面的 `shapes` 列表中，`Rectangle` 和 `Circle` 对象虽然类型不同，但都实现了 `area` 方法，因此可以统一调用 `area` 方法来计算面积。\n\n### 面向对象概念在具体包和函数中的应用\n\n在实际的 Python 编程中，面向对象编程的概念广泛应用于各种包和函数中。下面以 `pandas` 和 `matplotlib` 这两个常用的包为例进行说明。\n\n#### `pandas` 中的应用\n\n`pandas` 是一个用于数据处理和分析的强大包，其中大量使用了类和对象的概念。例如，`DataFrame` 是 `pandas` 中最常用的类之一，用于表示二维表格数据。\n\n\n\n\n此例中，`pd.DataFrame` 是一个类，`df` 是 `DataFrame` 类的一个对象。\n\n我们可以调用 `df` 对象的各种方法，如 `head()` 和 `describe()`，来对数据进行操作和分析。甚至可以采用链式调用的方式来连续执行多个操作，如 `df.describe().T.round(2)` 表示对 `df` 对象依次进行如下操作：计算基本统计量 &rarr; 转置 &rarr; 四舍五入 (保留两位有效数字)。\n\n\n\n#### `matplotlib` 中的应用\n\n`matplotlib` 是一个用于数据可视化的包，也广泛应用了面向对象编程的思想。例如，我们可以使用 `Figure` 和 `Axes` 类来创建和定制图形。\n\n\n\n\n\n在这个例子中，`fig` 是 `Figure` 类的对象，`ax` 是 `Axes` 类的对象。\n\n我们可以通过调用 `ax` 对象的方法，如 `plot()`、`set_title()`、`set_xlabel()` 和 `set_ylabel()` 来绘制和定制图形。这体现了面向对象编程在 `matplotlib` 中的应用，通过将图形的不同部分封装成对象，使得图形的创建和定制更加灵活和可控。\n\n\n## 包、函数、方法和属性\n\n我们先简要介绍一下理解复杂语句所需的基础概念。\n\n### 包（Package）和模块（Module）\n\n#### 模块（Module）\n\n- 模块是单个 `.py` 文件，包含函数、类、变量等代码。\n- 例如：\n  - `arrow.api.py` 是一个模块，包含 `get()` 函数。\n  - `numpy.random.py` 也是一个模块，内含若干个用于生成随机数的函数。\n\n#### 包（Package）\n\n包是一个包含多个模块的**目录**，通常还包含一个 `__init__.py` 文件。\n\n一个包中可以包含多个子包，而每个包中又可以包含多个模块。包的目录结构类似于文件系统的目录结构。`__init__.py` 文件的作用是标识该目录是一个包，更重要的是，它详细记录了这个包里都有哪些模块和子包。\n\n包通过目录结构组织代码，例如：\n\n  ```python\n  pandas/               # 根包\n    __init__.py         # 标识这是一个包\n    core/               # 子包\n      __init__.py\n      frame.py          # 模块（定义 DataFrame）\n      series.py         # 模块（定义 Series）\n    io/                 # 子包\n      __init__.py\n      excel.py          # 模块（处理 Excel 文件）\n  ```\n\n比如，`arrow` 是一个用于处理日期和时间的包，该包的程序文件存放于 `arrow` 目录下：\n\n![](https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250524004230.png)\n\n其中包含 `__init__.py` 文件和其他模块文件（如 `arrow.py`、`util.py` 等）。当你使用 `import arrow` 时，Python 会自动执行 `__init__.py` 文件中的代码，从而初始化包的命名空间。\n\n你若执行 `from arrow import api`，则会导入 `arrow` 包中的 `api` 模块。然后你可以使用 `api` 模块中的函数和类，例如 `api.get()`。\n\n\n同理，你可以使用如下方法查看其他包的路径：\n\n\n\n### 函数（Function）和方法（Method）\n\n函数是一段完成特定任务的独立代码块，可以直接调用。而方法是与对象关联的函数，必须通过对象来调用。例如，\n\n- 在 `sm.datasets.get_rdataset()` 中，`get_rdataset()` 是一个函数，它属于 `statsmodels` 包中 `datasets` 模块。\n- 在 `model1 = sm.OLS(y, X1).fit()` 中：\n  - `OLS()` 是 `sm` 包中的一个函数，用于创建一个普通最小二乘回归模型对象。\n  - `sm.OLS(y, X1)` 创建了一个 `OLS` **对象**。\n    - `fit()` 是 `sm.OLS(y, X1)` 创建的对象的**方法**。\n\n#### 类中的属性（Attribute）和方法（Method）\n\n**属性** 是类或对象的数据成员，而 **方法** 则是类或对象的函数成员。\n\n因此，在 `mtcars = sm.datasets.get_rdataset('mtcars', 'datasets').data` 中，`.data` 就是 `get_rdataset()` 函数返回的对象的一个属性，里面存储着对象里的数据。\n\n## 解析复杂语句\n\n现在我们来详细解析引言中提到的复杂语句：\n\n```python\nimport statsmodels.api as sm\n\n# 加载示例数据\nmtcars = sm.datasets.get_rdataset('mtcars', 'datasets').data\nmtcars.head()\n```\n\n具体解释如下：\n\n- `sm` 是 `statsmodels.api` 模块的别名。\n- `datasets` 是 `sm` 下的一个子模块，专门用于访问内置或外部数据集。\n- `get_rdataset('mtcars', 'datasets')` 是 `datasets` 子模块中的一个函数，用于从 R 的数据集仓库中的 **datasets** 包中获取名为 `'mtcars'` 的数据集。这个函数会返回一个包含数据集及其元信息 (meta information) 的对象 (可以假想为名称为 **mtcars_object** 的对象)。\n- `.data` 是对象 **mtcars_object** 的一个属性，用于提取实际的数据内容（通常为一个 `pandas.DataFrame`）。\n- 因此，最终得到的 `mtcars` 变量就是一个 `pandas.DataFrame` 对象，包含了 `'mtcars'` 数据集的实际数据。\n- `mtcars.head()` 是 `pandas.DataFrame` 对象的方法，用于查看数据集的前几行数据。\n\n需要注意的是，在上述语句中，`datasets` 这个关键词出现了两次，两者含义不同，不要混淆：\n\n- 第一次是指 `sm` 下的 `datasets` 子模块；\n- 第二次是作为参数传递给 `get_rdataset()` 函数，它是 R 语言中的一个扩展包的名称，而 `mtcars` 则是 **datasets** 包中的一个数据集。\n\n把上述代码拆成两行更有助于理解 **模块**、**函数** 和 **属性** 这三个概念的区别：\n\n```python\nimport statsmodels.api as sm\n\n# 获取数据集对象：'object = 模块.函数()' 格式\n#        本例中：'object = 模块.子模块.函数(参数1, 参数2)' 格式\nmtcars_object = sm.datasets.get_rdataset('mtcars', 'datasets') \n\n# 获取数据集内容：'object.属性' 格式\nmtcars_df = mtcars_object.data \n```\n\n可以将这行代码拆解为以下几步，更便于初学者理解：\n\n```python\n# 第一步：获取 datasets 子模块\ndatasets_module = sm.datasets\n\n# 第二步：调用 get_rdataset 函数获取数据集对象\nrdataset = datasets_module.get_rdataset('mtcars', 'datasets')\n  # - 'mtcars' 是数据集的名称\n  # - 'datasets' 是数据集所在的包名\n# 第三步：通过 data 属性获取实际的数据\nmtcars = rdataset.data\n```\n\n至此，代码的第二部分也很容易理解了：\n\n```python\n# 模型 1\nX1 = data[['weight']]\nX1 = sm.add_constant(X1)\ny = data['mpg']\nmodel1 = sm.OLS(y, X1).fit()\n```\n\n解释如下：\n\n- `sm.OLS(y, X1)`：\n    - `OLS` 是 `statsmodels.api` 模块中的一个类，用于创建一个普通最小二乘回归模型的对象。这里传入的参数 `y` 是因变量，`X1` 是自变量。\n- `.fit()`：是 `sm.OLS(y, X1)` 创建的对象的方法，用于拟合模型，即根据输入的数据计算模型的参数。\n\n \n\n\n## 参考资料\n\n- [Python 100 Days - 18.面向对象编程入门](https://github.com/jackfrued/Python-100-Days/blob/master/Day01-20/18.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8.md)\n\n\n\n\n## 总结\n\n- 模块是单个 `.py` 文件，包含函数、类、变量等代码。\n- 包是一个包含多个模块的目录，通常还包含一个 `__init__.py` 文件。\n- 类是对象的模板，它定义了对象的属性和方法。\n- 对象是类的实例。通过类能够创建多个不同的对象，每个对象都有自己独立的属性值。\n- 封装是将数据（属性）和操作数据的方法捆绑在一起，并对外部隐藏对象的内部实现细节。\n- 继承是一个类可以继承另一个类的属性和方法。\n- 多态是指不同的对象可以对同一个操作做出不同的响应。\n- 函数是一段完成特定任务的独立代码块，可以直接调用。\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"highlight-style":"atom-one","css":["../styles.css"],"output-file":"01_py_01_basic_05_OOP.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","editor":"visual","theme":"cosmo","linestretch":1.6,"fontsize":"11.5pt","highlight":true,"callout-appearance":"default","md-extensions":["callout"],"includes":{"after-body":"../_includes/counter.html"},"title":"Python：语法解析-面向对象编程"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}